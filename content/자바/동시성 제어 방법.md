## `synchronized` 키워드
- 설정한 메서드/블럭 에 한번에 한 스레드만 접근 가능하도록 제한한다.
- 객체락이기 때문에, 객체별로 락이 관리된다. (객체가 2개라면, 각각 동시 접근은 허용한다.)
- 사용이 간단하다.
- 프로세스(서버)가 여러개인 분산 환경에서는 사용이 불가능하다.
- 수정하려는 자원에 상관없이, 무조건 락을 걸기 때문에 성능이 안좋다. (락의 범위가 넓다고 표현한다.)
## `ReentrantLock`
- `synchronized`에 비해 좀 더 상세한 설정이 가능한 락이다.
	- 락 획득 대기시간 (`tryLock()`)
	- 공정성 제어 (`new ReentrantLock(true)`)
- `synchronized`에 비해 사용이 어렵다.
	- 코드 수준에서 직접 `lock()`, finally 문에서 `unlock()`을 해주어야 한다.
- `synchronized`가 가지는 단점(분산 불가능, 넓은 락 범위)는 그대로 가진다.
- 단, `ConcurrentHashMap<String, Lock> lockMap` 같은 방법으로 락 범위를 작게 만들 수 있다!
## Atomic 클래스
- CAS를 통해서 단순 증감 연산을 수행한다.
- 락의 범위가 메서드 호출 뿐이므로 좁고, CAS 연산의 속도가 우월하다.
- 단순 증감 연산 외에는 지원되지 않는다.
## 동시성 컬렉션
- `ConcurrentHashMap` : 삽입 작업은 key 별 직렬 / 조회 작업은 병렬
- `CopyOnWriteArrayList` : 삽입 작업은 직렬 / 조회 작업은 병렬
- `CopyOnWriteArraySet` : 동일
- `BlockingQueue`