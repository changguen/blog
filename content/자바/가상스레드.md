기존 스레드는 플랫폼 스레드, 즉 OS의 스레드를 진짜 사용한다. 한 JVM(프로세스) 안에 여러 스레드를 생성하여 사용한다.
가상스레드는 플랫폼 스레드를 사용하지 않고, JVM이 관리하는 가짜 스레드이다. OS의 커널이 생명주기/스케줄링 하는게 아니고, JVM이 한다.
## 더 로우레벨로
가상스레드는 스스로 실행될 수 없다. (OS 스레드가 아니니까) 따라서 이 가상스레드는 OS 스레드 위에 올라타야 하는데, 이 OS 스레드를 **캐리어 스레드**라고 부른다.
이렇게 마운트될 때 가상 스레드의 정보가 캐리어 스레드의 스택 메모리로 복사되어 실행된다.

**블로킹 발생시**
가상스레드가 블로킹 작업을 만나면 JVM이 이를 가로챈다.
가상스레드는 작업을 중단한다. (yield)
가상스레드의 현재까지의 작업 내용(로컬 변수, 스택 프레임 등)을 `Continuation`라는 객체로 바꾸어 힙 메모리에 저장한다.
가상스레드는 언마운트된다.
다른 가상스레드가 마운트된다.
## 왜 OS 스레드 교체보다 가상스레드 교체가 더 빠른가?
둘다 '하던 작업을 저장하고, 기존 작업을 불러온다' 라는 개념 자체는 동일하지만, 그 행위가 무엇을 건드리며 이루어지는지가 다르다.
- **모드의 변경**
	- OS 스레드는 유저 모드 -> 커널 모드로의 전환이 필요하다.
	- 가상스레드는 계속 유저 모드에서 실행된다.
- **변경하는 데이터의 종류와 양**
	- OS 스레드는 레지스터, 프로그램 카운터 등 하드웨어와 밀집한 모든 데이터를 저장하고 불러와야 한다.
	- 가상스레드는 소프트웨어적인 데이터만 힙으로 옮긴다.
- **캐시 오염**
	- OS 스레드의 변경은 CPU 캐시등을 오염/무효화시킬 확률이 높다. -> 초기 실행 속도가 느리다.
	- 가상스레드의 변경은 CPU를 잡고 있는 캐리어 스레드 자체는 동일하므로, CPU 캐시등의 데이터가 유효할 확률이 높다.
## 가상스레드 사용법
```java
// 단일 사용
Thread vThread = Thread.startVirtualThread(() -> {
    System.out.println("Virtual Thread");
});

// ExecutorService 통해 사용
try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i < 10000; i++) {
        executor.submit(() -> {
            System.out.println("Virtual Thread");
        });
    }
}
```
이외에도 톰캣의 스레드풀도 대신에 가상스레드를 사용하도록 수정할 수 있다.
이 경우 가상스레드가 제한없이 계속 생성된다.