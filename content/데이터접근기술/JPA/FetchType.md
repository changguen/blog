## FetchType 이란?

[[JPA 프록시|JPA]]에서 연관된 엔티티를 가져올 때, 한번에 쿼리해서 같이 가져올지, 나중에 필요해졌을 때 추가 쿼리를 통해 가져올지에 대한 타입이다.

예를 들어, `Team` - `Member` 관계에서 `Team`을 불러올 때 내부에 `List<Member>` 가 있을 경우, 한번에 join 연산을 통해 가져올지 VS 나중에 해당 필드에 접근할 때 추가 쿼리를 날릴지 정할 수 있다.

### 왜 사용하는가?

 위의 예시에서 보통 `Member`가 `Team` 마다 1억명씩 존재한다고 생각해보자. `Team` 을 조회할 때마다 1억명분의 무거운 쿼리가 나가게 되면 비효율적이다.

거기에다, 사람들이 보통 `Team` 에 대해서만 궁금하고 그 내부 내용까지는 궁금하지 않다면 굳이 보통의 상황에서 필요없는 `Member` 까지 조회하는 것이 비효율적이다.

이런 경우에 **정말 필요할 때**에 뒤늦게 쿼리를 날리는 방식으로 최적화할 수 있다.

## Eager

- join을 통해 한번에 무거운 쿼리를 날리는 방식 (한번에 다 가져온다)
- `ManyToOne`, `OneToOne` 의 경우 어차피 추가 내용이 많지 않으므로, 아주 조금 무거운 쿼리 VS 2 쿼리 를 비교했을 때, 아주 조금 무거운 쿼리가 이긴 듯 하다. 기본적으로 `Eager`이다.
- 사용 상황
    - 보통 같이 쓰이는 관계 사이에서 사용하면 좋다. (우테코 기수 → 크루)
    - 보통 적은 개수와 연관되는 관계 사이에서 사용하면 좋다. (자식 → 부모)

## Lazy

- [[JPA 프록시]]의 프록시 방식을 통해 뒤늦게 쿼리를 날리는 방식
- `OneToMany`, `ManyToMany` 의 경우에서 한번에 가져오려고 노력하면 매우 무거운 쿼리가 나갈 수도 있으므로, 기본으로 `Lazy` 이다.
- 사용 상황
    - 보통 같이 쓰이지 않는 관계 사이에서 사용하면 좋다. (회원 → 알림 설정 정보)
    - 보통 많은 개수와 연관되는 관계 사이에서 사용하면 좋다. (지구 → 인류)
- 주의! [[N+1 문제 상황 총정리|N+1]]
    - `~ToMany` 의 상황에서 `Lazy` 를 쓰게 되면, 추가 쿼리가 N개 발생할 수 있다.
    - Team 조회 1번, Member 조회 N번 → 1 + N → N + 1 문제라고 불린다.
    - Member를 순회하며 JPA가 N번 쿼리하도록 하지 말고, 그냥 Team과 관계된 Member를 한번에 조회하도록 하자. → 1 + 1 문제로 줄어든다.
    - [[EntityGraph]]나 Fetch Join을 통해 해결할 수 있다.