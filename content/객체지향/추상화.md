: 불필요한 세부 정보는 생략하고, **중요한 행동**만 뽑아내어 모델링하는 것이다.
- 다르게 말하면, **구현과 역할을 분리**하는 행위다.
- 자바에서 구현은 보통 추상클래스나 인터페이스를 통해 수행된다.
### 장점
- 코드 작성과 **협업**이 쉬워진다.
	- A를 위해서 B가 필요하고, B를 위해서 C가 필요하면 C부터 바텀업으로 개발해나가야 한다.
	- 이러면 혼자 개발할 때에도 구현의 흐름이 끊겨서 힘들고, 협업할 때에도 동시다발적 개발이 어렵다.
	- 하지만 중간에 API를 통해 A -> B <- D -> C 같은 추상화를 끼워두면, 전파되는 복잡성을 멈출 수 있다.
	- ! 하지만 지금 편하려고 불필요한 추상화를 하는 것은 미래의 기술 부채를 만드는 행위다.
- 다른 구현을 끼워넣기 쉬워진다.
	- API에만 의존하므로, 구현이 바뀌더라도 해당 객체는 수정이 필요하지 않다.
	- [[SOLID#OCP(개방 폐쇄 원칙)|OCP]]개념으로도 이어진다.
	- ! 이 말은 다른 구현이 필요없을 것이 확정적이라면, 추상화가 필요없다는 말이다.
- 테스트가 매우 쉬워진다.
	- 의존하는 대상이 구현체였을 경우에는 해당 구현체나 그 자식 클래스만이 들어올 수 있다.
	- 네트워크/외부API/DB 등 무거운 의존성들을 준비하고 실행하는데에는 시간이 많이 들고, 위험할 수도 있다.
	- [[SOLID#OCP(개방 폐쇄 원칙)|OCP]]를 활용하여 가벼운 구현을 끼워넣으면 테스트가 쉽다.
	- ! 물론 요즘은 테스트 도구들(Mockito 등)이 잘 발달되어서 테스트가 불가능한 것은 아니다. 따라서 '테스트를 위해서 만든다' 보다는 '추상화가 필요해서 했더니, 테스트도 너무 쉽다'가 적절한 표현이다.
- **비즈니스 로직을 보호할 수 있다.** ([[SOLID#DIP(의존성 역전 원칙)|DIP]])
	- 추상화하지 않으면 무의식적으로 비즈니스 로직에 하위레벨 구현이 침투하는 경우가 발생할 수 있다.
	- 이렇게 계속 개발해나가면 정말 중요한 로직과 구현 기술이 섞여 코드의 가독성도 떨어지고, 유지보수하기 매우 어려워진다.
- 추상화레벨을 맞출 수 있다.
	- 비즈니스 로직과 구현 기술이 섞이면, 해당 객체를 수정하는 이유가 여러개 생긴다.
	- 이러면 협업에도 불리하며, 수정 자체가 어려워진다.
	- 추상화를 활용하면 비즈니스 로직이 중요한 API에만 의존하게 되므로, 둘을 떼어놓을 수 있다.
### 단점
- 설계 비용 증가
	- 중요한 행동만 뽑아내는 과정은 도메인에 따라 매우 어려울 수 있다.
- 설계적 복잡성 증가
	- 파일의 개수가 2배로 빠르게 불어나므로, 객체간 의존성이나 구성을 한번에 이해하기 어려워진다.
- 롤백 어려움
	- 추상화를 추가하는 일보다 추상화를 제거하는 일이 훨씬 고통스럽다.
	- IDE가 추상화 리팩터링은 잘 적용해주지만, 역 추상화는 사람이 해야 한다.
- 설계적 실패
	- 미래의 변경을 대비하여 추상화를 했지만, 실제로 변경된 구현이 추상화와 맞지 않는 경우도 많다.
	- 이런 경우 API도 수정해야 하는데, 수정 비용이 배로 증가한다.
	- 미래를 완벽하게 대비하는 것은 불가능에 가깝다.
### 내 생각
- 추상화는 장점과 단점이 정말 명확하다.
- '미리 하는 추상화'에 대해서는 **미래의 기술 부채를 남기는 일**이라고 생각한다.
- 아마 나는 KISS, YAGNI 원칙을 좀 더 좋아하는 것 같다.
	- 필요할 때(=구현체 변경 등) 그때 해도 늦지 않는다고 생각한다.
- 결국 회사에서는 팀적 합의가 매우 중요할 것 같다.
- 팀적으로 이해받기 위해서는 어떠한 정량적 측정이 필요한데, 다음과 같은 수치들을 고려해볼 수 있다.
	- 변경 가능성
	- 변경시 수정 비용
	- 불확실성