### Session 인증 작동 방식

1. 클라이언트가 ID, PW 전송
2. 서버에서 인증 후 **세션을 생성하여 저장**
3. 서버에서 세션ID를 쿠키로 발급
4. 이후 클라이언트는 세션ID가 담긴 쿠키와 함께 요청
5. 서버는 해당 세션ID로 **세션 저장소에서 찾아서 인증**

### Token 인증 작동 방식 - 쿠키

1. 클라이언트가 ID, PW 전송
2. 서버에서 인증 후 **토큰을 생성하여 쿠키로 발급**
3. 이후 클라이언트는 토큰이 담긴 쿠키와 함께 요청
4. 서버는 **쿠키에서 토큰을 추출한 후 검증하여 인증**

### Token 인증 작동 방식 - 헤더

1. 클라이언트가 ID, PW 전송
2. 서버에서 인증 후 **토큰을 생성하여 응답으로 반환**
3. 이후 클라이언트는 `Authorization` 헤더에 해당 토큰을 포함하여 요청
4. 서버는 **헤더에서 토큰을 추출한 후 검증하여 인증**

## 보안성 비교

- 쿠키 기반 기능(세션, 토큰-쿠키)
    - CSRF에 약하다. 다른 곳으로 요청해도 쿠키가 자동 전송될 가능성이 있기 때문이다.
    - XSS에 강하다. httpOnly를 사용하는 경우 JS에서 쿠키에 접근이 불가능하기 때문이다.
- 헤더 기반 기능(토큰-헤더)
    - CSRF에 강하다. JS를 통해 명시적으로 헤더로 전송해야 하기 때문이다.
    - XSS에 약하다. JS를 통해 로컬스토리지가 노출될 가능성이 있기 때문이다.

## 성능 비교

- 토큰 기반 기능(토큰-쿠키, 토큰-헤더)
    - 저장소가 불필요하다. 따라서 여러 서버를 띄울 수도 있는 등, 확장성이 높다.
    - 응답 속도가 빠르다. 저장소를 거칠 필요가 없이 토큰 자체로 검증 가능하기 때문이다.
    - 네트워크 비용이 높다. 토큰 크기가 크기 때문이다.
- 세션 기반 기능
    - 저장소가 필요하다.
    - 응답 속도가 느리다. 세션 저장소를 거쳐야 하기 때문이다.
    - 네트워크 비용이 낮다. 세션ID 자체는 매우 짧기 때문이다.
- 결론
    - 토큰은 저장소가 불필요하다.
    - 토큰은 응답 속도가 빠르다.

## 그러면 왜 세션을 사용하는가?

- 세션은 인증 정보가 세션 저장소에 저장된다.
- 따라서 세션 저장소에 특정 행을 삭제하여 빠르게 차단할 수 있다.
- 또한 토큰이 일부 정보를 포함하는데 비해, 세션ID는 아무런 값도 아니므로 민감 정보 노출 위험성이 없다.

## 토큰 VS 세션

- 토큰은 저장소가 필요없다.
- 토큰은 응답 속도가 빠르다.
- 세션은 즉시 차단이 가능하다.
- 세션은 민감 정보가 서버측에만 저장된다.
- 활성 상태가 유지시, 서버측에서 세션의 유효기간을 늘릴 수 있다. (재로그인 불필요)

## Refresh Token

- 토큰 방식은 유효기간이 지나면 사용하지 못한다.
- 즉, 재로그인이 필요하다. → UX↓
- 따라서 AccessToken과 함께 RefreshToken을 발급하여, UX를 늘리는 기법이 존재한다.
- 방법
    - 서버 검증 시, AccessToken이 만료되면 예외 응답을 보낸다.
    - 클라이언트는 해당 응답을 받고 RefreshToken을 제출한다.
    - 서버는 RefreshToken을 검증하고, 검증되었다면 해당 유저의 AccessToken을 발급하여 반환한다.
    - 클라이언트는 이후 새로운 AccessToken으로 요청한다.
- 또한 RefreshToken을 토큰 저장소에 저장하는 형태를 사용하면, RefreshToken이 탈취되었을 때 비활성화시킬 수 있다.
    - 하지만 결국 다시 저장소를 사용하게 된다.

## 토큰 + Refresh + 차단 VS 세션

- 둘다 저장소가 필요하다.
- 둘다 차단이 가능하다. (토큰은 AccessToken 기간 동안 기다려야 한다, RefreshToken은 즉시 차단 가능)
- 토큰은 응답 속도가 빠르다. (AccessToken으로만 검증 가능)
- 세션은 민감 정보가 서버측에만 저장된다.