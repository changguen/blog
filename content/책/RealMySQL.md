## 4장 : 트랜잭션과 잠금
---
- 트랜잭션은 데이터의 정합성을 보장하는 개념
- 락은 동시성을 제어하는 개념
### 트랜잭션
트랜잭션은 최대한 짧게 유지해야 한다. 트랜잭션이 길어질수록 여유 커넥션의 개수는 줄어든다.
### 락
#### 락의 범위
- `레코드 락` : 레코드 자체만을 잠근다. 다만, 인덱스의 대상이 레코드 자체가 아니라 `인덱스 레코드`이다. 인덱스가 없는 경우에는 자동 생성된 숨겨진 클러스터 인덱스에 걸린다.
  InnoDB는 인덱스를 통해서만 데이터 접근하기 때문이다.
- `갭 락` : 레코드 사이의 간격에 락, [[트랜잭션 사이의 읽기 문제들#Phantom reads|팬텀리드]]를 방지한다.
- `넥스트키 락` : 레코드락 + 갭락 조합, [[트랜잭션 사이의 읽기 문제들#Phantom reads|팬텀리드]] 와 [[트랜잭션 사이의 읽기 문제들#Non-repeatable reads|반복할 수 없는 읽기]]를 방지하기 때문에 `REPEATABLE READ` 의 핵심이다.
#### 락의 방식
- [[락#비관적 락|비관적 락]]
- [[락#낙관적 락|낙관적 락]]
#### [[락#락과 인덱스의 관계|락과 인덱스의 관계]]
락을 인덱스에 걸기 때문에 인덱스로 줄이는 만큼만 락이 걸린다.
`name = dompoo, age = 10` 쿼리를 실행하는 상황에서
- 인덱스가 없으면 전체 1000개 레코드에 레코드 락이 걸린다. (숨겨진 클러스터 인덱스 사용)
- name에만 인덱스가 걸려 있으면 500개 레코드에 레코드 락이 걸린다. (인덱스 사용)
- 두 칼럼 모두 인덱스가 걸려 있으면 3개 레코드에 레코드 락이 걸린다. (인덱스 사용)
따라서 인덱스를 잘 걸어야 락도 잘 걸린다.
#### 트랜잭션 격리 수준과 락
트랜잭션 격리 수준은 락을 통해서 이 문제를 해결한다.
예를 들어, `REPEATABLE_READ` 격리 수준에서는 넥스트키 락을 사용하게 된다.
따라서 격리 수준을 낮추는 것은 락을 덜 걸게 만드는 방법이다.
#### [[트랜잭션 격리 레벨]]
## 5장 : 인덱스
---
### 인덱스의 저장 방식
- [[B+Tree 인덱스]]
- [[Hash 인덱스]]
- [[R-Tree 인덱스]]
- (책에서는 B-Tree라고 하는데 B+Tree이다.)
### 성능에 영향을 미치는 요소
- **인덱스 키 값 크기**
	- 인덱스 키 값이 크면 한 노드에 가질 수 있는 키가 줄어든다. (노드의 크기는 페이지 크기에 맞춰진다.)
	- 따라서 인덱스 키 값이 크면 노드가 더 많아지고, 따라서 깊이가 더 커진다.
	- 깊이가 더 커지면 성능이 안좋아진다.
- 선택도
	- 인덱스에 포함된 칼럼이 중복이 없을 수록 좋다.
	- 중복이 많아지면 인덱스로 필터링한 후의 데이터들에 대하여 추가 연산이 늘어난다.
	- 예를 들어, 1000건 데이터에서
		- 성별로 인덱스를 걸면 평균 500건의 데이터를 추가 검색해야 한다.
		- 이름으로 인덱스를 걸면 평균 2건의 데이터를 추가 검색해야 한다.
- 여러 데이터를 읽어야 하는 경우
	- 100건 중 50건을 읽는 쿼리에 대하여
		- 50개를 인덱스없이 읽으며 버리는 것이 효율적일지
		- 50개를 인덱스를 통해 선택하는 것이 효율적일지
	- 이런 경우에 대해서는 직접 테스트해보는 것이 좋을 듯 하다.
### [[인덱스를 읽는 방법]]
### 다중 칼럼 인덱스
- 여러 칼럼으로 인덱스를 만들면 한 노드에 여러 개의 인덱스 레코드가 저장된다.
- 첫번째 칼럼을 기준으로 먼저 정렬되고, 같은 데이터에 대해서 두번째 칼럼을 기준으로 정렬된다.
- **따라서 두번째 칼럼만 사용하는 쿼리에선 해당 인덱스를 사용할 수 없다.**
### 인덱스 정렬
- 인덱스는 기본적으로 오름차순으로 정렬되어 저장된다.
- 이를 역순으로 읽기만하면 내림차순으로 읽게 된다.
### [[인덱스 잘 걸기]]
### [[클러스터링 인덱스]]
## 6장 : 실행 계획
---
[[실행 계획 확인]]
