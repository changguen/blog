## 복제 방법
- **단일 리더 복제**
	- primary가 데이터를 수정하고, 이 변경 사항을 로그/스트림 의 형식으로 넘겨주면 secondary에서도 이것을 반영한다.
	- 이 형태에서는 쓰기는 primary에만 허용된다.
	- 보통은 문제가 없지만, secondary가 장애를 복구 중이거나, 네트워크 이슈에서는 문제가 더 커질 수 있다.
- **다중 리더 복제**
	- 단일 리더 복제만으로도 보통 충분하다.
	  하지만 모든 쓰기를 하나의 primary가 처리하기 어려울 경우 다중 primary를 활용할 수 있다.
	- 아키텍쳐적으로 한 primary의 변경 사항은 다른 primary에게 전달되어 충돌이 해소되어야 한다.
	- 두 primary에서 동일한 데이터를 다르게 수정했을 때의 충돌을 해소해야 한다.
	  이외에도 여러 문제들이 발생할 수 있으므로 최대한 피해야하는 아키텍쳐이다. (자동 증가 키, 트리거, 무결성 제약 등)
- **리더 없는 복제**
	- 모든 노드가 쓰기와 읽기를 받을 수 있는 평등한 구조이다.
	- 클라이언트가 직접 여러 노드에 쓰기를 전송하거나, 코디네이터를 통해서 수행되기도 한다.
	- 이런 아키텍쳐에서 노드 중 몇개가 다운되더라도 과반수 노드가 쓰기되었다면 OK, 읽을 때도 과반수 노드의 응답을 읽는 유연한 구조를 채택할 수 있다.
	  MongoDB의 정족수 개념이 여기서 나온다.
		- 복구는 읽을 때 수행할 수 있다. 읽었는데 과거 데이터를 응답하는 노드는 새로운 값으로 업데이트한다.
		- 또는 백그라운드로 계속 차이점을 찾으면서 업데이트할 수 있다.
## 복제 타이밍
- **동기**
	- secondary에 복제가 끝난 것을 확인한 후에, primary가 응답한다.
	- secondary가 최신 데이터 복사본을 가지고 있는 것이 보장된다.
	  -> primary가 죽어도 secondary를 통해 읽기가 가능하다.
	- secondary가 죽으면 primary를 통한 쓰기가 불가능하다.
	  -> 현실적으로 팔로워 1개 정도만 동기를 하고, 나머진 비동기로 한다. (=반동기)
- **비동기**
	- secondary에 메시지만 전송하고 곧바로 응답한다.
	- 따라서 primary에 문제가 생기고 복구가 불가능하면 쓰기는 유실된다.
	- 새로운 secondary가 primary를 따라잡는 방법
		1. primary의 스냅샷을 가져와서 복사한다.
		2. 스냅샷 이후의 모든 데이터 변경을 가져와서 처리한다.
## 장애 복구 방법
- secondary 장애 : 살아났을 때, 변경 로그로부터 가장 마지막 작업을 확인하고, 그 이후 모든 데이터 변경을 primary에서 가져와서 처리한다.
- primary 장애 (보통 이것을 failover 라고 한다.)
	- 새로운 primary를 선택한다. (선출 과정이나, 제어 노드 등에 의해 뽑히며, 보통 가장 최신 데이터 변경 사항을 가진 복제이다.)
	- 이전 primary 대신에 새로운 primary가 리더가 되도록 시스템을 설정한다.
- failover에서 발생할 수 있는 문제
	- 비동기식 복제에 의하여 새로운 primary가 옛날 데이터를 가진다.
	- 특정 결함 시나리오에서 여러 primary가 존재하는 스플릿 브레인 현상이 발생한다.
	- primary가 죽었다고 판단할 타임아웃을 적절하게 설정하기 어렵다.
## 복제 데이터 전달 방법
### 구문 기반 복제
- 구문(SQL)을 secondary에 전달하는 방식이다.
- 간단하지만 문제가 있다.
	- `NOW()`, `RAND()` 같은 함수가 노드마다 다를 수 있다.
	- 자동 증가 칼럼이 있다면, 모든 구문은 동일한 순서로 실행돼야 한다.
- 하지만 간편하기 때문에 여전히 잘 사용되기도 한다.
- MySQL은 구문에 비결정성이 있는 것을 감지하고 로우 기반 복제로 변경한다.
### 로그 전달
- primary가 자체 로그를 남기기 전에 secondary에 전달하는 방식이다.
- 이 로그는 보통 매우 저수준이며, 따라서 저장소 엔진의 종류와 버전에 영향을 받는다. -> 모든 노드들의 DB 버전이 동일해야 하며, 운영이 어렵다.
### 로우 기반 로그 복제
- 로그 전달과 유사하지만, 저장소의 로그와 구분되는 논리적 로그를 따로 남긴다.
- 이 로그는 각 로우에 대한 변경을 남긴다.
- 논리적(추상화된) 로그 덕분에 하위 호환성을 더 쉽게 유지할 수 있다.
- 또한 이 로그를 외부에서 읽도록 하여 [[CDC]] 등도 가능하다.
### 트리거 기반 복제
- 애플리케이션 코드를 좀 더 개입시키는 방식이다.
  변경이 발생했을 때, 코드가 트리거 되며 이 코드가 데이터의 서브셋을 다른 테이블에 기록하는 등의 작업을 수행한다.
---
## 참고
- [[복제 지연]] 문제