- 일반적으로 복제 아키텍쳐에서 쓰기는 primary에만, 읽기는 모든 secondary에 가능하다.
  보통 쓰기에 비해 읽기가 많기 때문에, 이 부하를 수많은 secondary를 통해 분산할 수 있다.
- 이런 아키텍쳐에서는 secondary를 추가하여 읽기 용량을 늘릴 수 있으나, 따라서 더욱 **비동기식 복제가 요구**된다. (동기식 복제는 점점 느려진다.)
- 비동기식 복제에서는 secondary가 뒤쳐지면 과거의 정보를 읽을 수도 있다. 결론적으로는 [[최종 일관성]]이 맞춰지나, 중간의 상태는 아닐 수 있는 것이다.
- **이런 지연에 의하여 발생할 수 있는 문제를 '복제 지연 문제'라고 부른다.**
## 문제1 : 자신이 쓴 내용 읽기
- 비즈니스 흐름 상, 사용자가 쓴 내용을 바로 볼 때 발생한다.
- primary에 쓰고, 그 데이터를 secondary에서 읽을 때, 찾지 못하는 것이다.
- 이 문제를 위한 일관성을 **쓰기 후 읽기 일관성**이라고 부른다.
### 쓰기 후 읽기 일관성 구현법
- 사용자가 수정한 내용은 primary에서 읽기
	- 예를 들어, 인스타그램 프로필 확인 API에서, 자기 프로필은 primary에서, 남의 프로필은 secondary에서 읽는다.
	- 단, 사용자가 대부분의 편집할 수 있다면 읽기가 primary에 몰리기 때문에 효율적이지 않다.
- 사용자의 타임스탬프를 처리할 수 있는 노드 찾기
	- 클라이언트가 마지막 쓰기의 타임스탬프와 함게 요청하면, 이를 기반으로 처리하는 것이다.
	- 해당 타임스탬프까지 따라잡을 때까지 질의를 대기시키거나, 다른 secondary로 넘겨볼 수 있다.
## 문제2 : 시간이 거꾸로 흐르는 읽기
- 사용자가 2번 읽었을 때, 처음 읽은 secondary가 두번째에 비해 더 최신 데이터를 반영하고 있는 경우, 시간이 거꾸로 흐르는 것처럼 느낀다.
- 이 문제를 해결하기 위해서는 여러번 읽을 때, 그것보다 예전 데이터를 읽지 않는 **단조 읽기**가 요구된다. (단조 읽기는 [[강한 일관성]]보다 덜하지만, [[최종 일관성]]보다는 강하다.)
- 단조 읽기는 각 사용자의 읽기가 항상 동일한 노드에서 수행되도록 하여 달성한다.
## 문제3 : 인과성 위반
- 데이터를 쓴 순서와 읽는 순서가 달라지는 현상이다.
  보통은 문제 없지만, 두 쓰기 간의 인과성이 있는 경우 읽기가 이상해진다.
- 이를 해결하기 위해서는 **일관된 순서로 읽기**가 필요하다.
- 서로 인과성있는 쓰기가 동일한 파티션에 기록되도록 하여 처리한다.