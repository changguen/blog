> [[복제]]는 동일한 데이터의 복사본을 여러 노드에 저장하는 것이다.
> **파티셔닝은 데이터셋이 너무 크거나, 쿼리양이 매우 높을 때, 데이터를 쪼개는 것이다.**
## 방법
- **키 범위**
	- 키의 최소값부터 최대값까지 구한 후, 이를 적절히 나눈다.
	- 이 때, 각 파티션이 가지는 키의 범위가 동일하지 않아도 된다. 데이터가 특정 키들에 집중될 수 있기 때문이다.
	- 이러면 각 파티션에서는 키를 정렬된 순서로 저장할 수 있다.
	- 하지만 정렬되었다는 것은 패턴이 있다는 것이고, 이것은 특정 상황에서의 핫스팟을 낳는다.
- **해시 함수**
	- 해시 함수는 쏠린 데이터를 균등하게 분산되게 한다. 위 상황에서의 문제를 해결한다.
	- 하지만 인접했던 키들이 모두 흩어지므로 정렬 순서가 유지되지 않고, 범위 쿼리 등에서 모든 파티션에 쿼리를 전송해야 할 수 있다.
- 키 범위 + 해시 함수
	- 키를 하나의 칼럼에 대해 수행하지 않고, 여러 칼럼에 대해 수행하는 것이다.
	- 칼럼 A + B + C를 키로 두고, A는 해시, BC는 정렬하여 같은 파티션에 둔다.
	- 이러면 A에 대해서는 범위 질의를 수행하지 못하지만, BC에 대해서는 가능하다.
## 보조 인덱스가 존재하는 파티셔닝
- **문서 기준 보조 인덱스 (지역 색인)**
	- 보조 인덱스는 파티셔닝의 기준이 아니므로, 보조 인덱스는 각 파티션마다 존재하게 된다.
	- 따라서 모든 파티션으로 쿼리를 보내서 결과를 조회해야 한다.
- **용어 기준 보조 인덱스 (전역 색인)**
	- 저장 자체는 기본키를 기반으로 하지만, 보조 인덱스 자체는 다른 기준으로 파티셔닝 해두는 것이다.
	  예를 들어, 파티션1에는 0~10의 기본키를 저장하고, 보조 인덱스로는 빨강/파랑을 저장한다. 파티션2에는 10~20의 기본키를 저장하고, 보조 인덱스로는 노랑/초록을 저장한다.
## 파티션 재균형화
- 노드를 추가하거나, 기존 노드를 잠깐 다운시켜야 하면 파티션의 재균형화가 필요해진다.
- 재균형화는 다음과 같은 내용이 만족되어야 한다.
	- 재균형화 중에도 부하를 받아들여야 한다.
	- 재균형화 이후에 부하는 균등하게 분배된다.
- **파티션 개수 고정**
	- 파티션을 미리 많이 만들어 놓고, 각 노드가 여러개씩 배정받는 방식이다.
	- 이 작은 파티션들을 노드간에 이동시키면 된다. (A : 12 파티션, B : 34 파티션, C : 56 파티션 -> A : 125 파티션, B : 346 파티션)
	- 이 방식에서 파티션 개수는 보통 노드의 최대 개수가 되므로, 초기에 적절하게 설정해야 한다.
- **동적 파티셔닝**
	- 한 파티션의 크기가 너무 커지면 이를 나누어 작은 2개의 파티션으로 나누는 방식이다.
	  반대로 너무 작으면 병합할 수도 있다.
	- 자동적으로 파티션의 개수가 조정되면서 이를 남은 노드들에 나눠주는 방식이다.
- **노드 비례 파티셔닝**
	- 동적 파티셔닝은 '크기'를 기준으로 자동적으로 조정된다면, 노드 비례 파티셔닝은 '개수'를 기준으로 조정된다.
	- 각 파티션은 비슷한 크기를 가지는 상황에서, 파티션 개수는 모든 노드에서 동일하도록 조정된다.
## 요청 라우팅
- 크게 3가지 방법이 있다.
	- 클라이언트 -> 아무 노드 -> 직접 처리하거나 대상 노드
	- 클라이언트 -> 라우터 -> 대상 노드
	- 클라이언트 -> 대상 노드
- 결국 라우팅 결정을 내리는 대상에 따라 형태가 달라지는 것이다.
- 중요한 것은 결정을 어디서 내리든, 그 라우팅 정보를 항상 최신으로 유지하는 것이다.
  각 데이터베이스마다 자신의 방법을 쓰든 주키퍼같은 코디네이터를 쓴다.