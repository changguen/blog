## 비관적 락에서의 데드락
- 데드락이란 두 트랜잭션이 서로의 락을 획득하기 위해 무한 대기하는 현상이다. (보통 무한대기하지는 않고, 타임아웃된다.)
- 시나리오
    - 트랜잭션1 : 회원1 조회 성공, 락 획득
    - 트랜잭션2 : 회원2 조회 성공, 락 획득
    - 트랜잭션1 : 회원 2 조회 시도, 락 획득 대기
    - 트랜잭션2 : 회원 1 조회 시도, 락 획득 대기
    - — 무한대기 —
## 해결 방법
### 동일 테이블 락 획득 순서 일치
```java
void run(List<Long> ids) {
	memberDB.findAll(ids);
}
```
- 동일 테이블에 대한 다른 칼럼을 잡고 서로를 요구하는 상황이 발생할 수 있다.
	- `run(List.of(1,2,3)) & run(List.of(3,2,1))`
- 해결방법 : 순서를 항상 일치시킨다.
```java
void run(List<Long> ids) {
	Collections.sort(ids);
	memberDB.findAll(ids);
}
```
### 여러 테이블 락 획득 순서 일치
```java
void run1(int memberId, int productId) {
	memberDB.find(memberId);
	productDB.find(productId);
}

void run2(int memberId, int productId) {
	productDB.find(productId);
	memberDB.find(memberId);
}
```
- `run1(1, 2)`, `run2(1, 2)` 를 동시에 실행시키면 데드락에 걸릴 수 있다.
- 해결방법
	- 전역적인 락 획득 테이블 우선순위 정의
	- 락 획득 헬퍼 클래스를 통해 락 획득
	- `테이블명+ID` 를 정렬한 순서를 기준으로 락 획득
### 긴 트랜잭션 해소
- 트랜잭션이 길어질수록 락 획득 시간이 늘어나며, 다른 락을 추가 획득할 가능성이 높고, 다른 트랜잭션과의 충돌 확률을 높이게 된다.
- 해결방법
	- 외부 API 호출은 락을 획득하고 수행하지 않는다.
	- 복잡한 계산 전후로 락을 획득한다.