- 여러 트랜잭션이 공유 자원에 동시 접근할 때 생기는 데이터 정합성 문제를 해결하기 위한 수단이다.
- 쓰기 연산 자체가 동시에 작동하지는 않으나, 쓰기 연산을 위한 읽기 연산부터 하나의 단위로 진행되어야 하는 경우 주로 사용한다.
## 락의 종류
- 크게 **낙관적 락과 비관적 락**으로 나뉜다.
### 비관적 락
- 충돌이 발생할 것을 가정하고, 미리 락을 건다.
- 위 예시에서 한 쿠폰에 대하여 스레드1이 락을 걸면, 나머지 스레드2,3,4는 락을 획득하기 위해 대기하게 된다.
- 즉, 병렬적으로 처리되던 서버가 쿠폰 사용에 대해서만큼은 직렬적으로 작동하게 된다.
- 비관적 락은 **공유락과 배타락**으로 나뉜다.
- **공유락** : 읽기 작업에 사용하며, 다른 트랜잭션도 읽기는 가능하나, 쓰기가 안된다.
- **배타락** : 쓰기 작업에 사용하며, 다른 트랜잭션은 읽기도 안된다.
### 낙관적 락
- 충돌이 드물 것을 가정하고, 커밋 시점에 충돌을 검사하는 방식이다.
- 위 예시에서 한 쿠폰에 대하여 스레드1,2,3,4가 모두 v1인 쿠폰을 조회한다. 그 후, 스레드1이 가장 빨리 사용하게 되어 쿠폰은 v2가 되고, 스레드2,3,4는 사용하려고 할 때에, 버전이 불일치하는 것을 감지, 롤백한다.
### 장단점
- 비관적 락
    - 미리 락을 걸기 때문에, 무조건 성공한다.
    - 하지만 그 동안 다른 스레드가 작업하지 못하므로 느리다.
    - **[[데드락]]이 발생할 수 있다.**
- 낙관적 락
    - 기본적으로 락을 걸지 않아 빠르다.
    - 충돌이 자주 발생하는 경우 오버헤드가 증가한다.
## 사용 방법
- Spring Data JPA를 사용할 때에는 애노테이션을 바탕으로 손쉽게 락을 걸 수 있다.
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select c from Coupon c where c.id = :id")
Optional<Coupon> findByIdWithLock(@Param("id") Long id);
```
- `LockModeType` 이 필수이며 옵션은 다음과 같다.
    - `OPTIMISTIC` , `READ` : 낙관적 락
    - `OPTIMISTIC_FORCE_INCREMENT` , `WRITE` : 낙관적 락, 수정하지 않았어도 버전 증가한다.
    - `PESSIMISTIC_READ` : 비관적 락 (공유락)
    - `PESSIMISTIC_WRITE` : 비관적 락 (배타락)
    - `PESSIMISTIC_FORCE_INCREMENT` : 비관적 락, 베타락을 획득하며 낙관적락의 버전도 증가시킨다.
    - `NONE`
- 낙관적 락을 사용하기 위해서는 엔티티에 `@Version` 애노테이션도 붙여야 한다.
## 락과 인덱스의 관계
- 인덱스는 락의 범위를 결정한다. (DB마다 결과 자체는 다 다름)
    - 인덱스가 없어 전체 테이블 스캔시 → 모든 행이 락에 걸린다. → 동시성이 떨어진다.
    - 인덱스가 있어 테이블을 조금만 스캔시 → 해당 행들만 락이 걸린다.
    - 인덱스로 커버되어 원하는 행들만 스캔시 → 원하는 행들에만 락이 걸린다.