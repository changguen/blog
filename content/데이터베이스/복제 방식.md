- 데이터가 시간이 지나도 변경되지 않는다면 복제는 쉽다.
- 모든 어려움은 변경 처리에서 오며, 이를 처리하기 위해서 다음과 같은 인기있는 방식들이 있다.
- **복제 방법** : `primary 기반 복제`
	- primary가 데이터를 수정하고, 이 변경 사항을 로그/스트림 의 형식으로 넘겨주면 secondary에서도 이것을 반영한다.
	- 이 형태에서는 쓰기는 primary에만 허용된다.
	- 보통은 문제가 없지만, secondary가 장애를 복구 중이거나, 네트워크 이슈에서는 문제가 더 커질 수 있다.
- **복제 타이밍** : 동기 vs 비동기
	- 동기
		- secondary에 복제가 끝난 것을 확인한 후에, primary가 응답한다.
		- secondary가 최신 데이터 복사본을 가지고 있는 것이 보장된다.
		  -> primary가 죽어도 secondary를 통해 읽기가 가능하다.
		- secondary가 죽으면 primary를 통한 쓰기가 불가능하다.
		  -> 현실적으로 팔로워 1개 정도만 동기를 하고, 나머진 비동기로 한다. (=반동기)
	- 비동기
		- secondary에 메시지만 전송하고 곧바로 응답한다.
		- 따라서 primary에 문제가 생기고 복구가 불가능하면 쓰기는 유실된다.
- 새로운 secondary가 primary를 따라잡는 방법
	1. primary의 스냅샷을 가져와서 복사한다.
	2. 스냅샷 이후의 모든 데이터 변경을 가져와서 처리한다.
### 장애 복구 방법
- secondary 장애 : 살아났을 때, 변경 로그로부터 가장 마지막 작업을 확인하고, 그 이후 모든 데이터 변경을 primary에서 가져와서 처리한다.
- primary 장애 (보통 이것을 failover 라고 한다.)
	- 새로운 primary를 선택한다. (선출 과정이나, 제어 노드 등에 의해 뽑히며, 보통 가장 최신 데이터 변경 사항을 가진 복제이다.)
	- 이전 primary 대신에 새로운 primary가 리더가 되도록 시스템을 설정한다.
- failover는 완벽하기 어렵다. 다음과 같은 문제가 존재한다.
	- 비동기식 복제에 의하여 새로운 primary가 옛날 데이터를 가진다.
	- 특정 결함 시나리오에서 여러 primary가 존재하는 스플릿 브레인 현상이 발생한다.
	- primary가 죽었다고 판단할 타임아웃을 적절하게 설정하기 어렵다.

### 리더 기반 복제의 내부 동작 방식들
