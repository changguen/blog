- 여러 DB/서비스에 걸쳐 수행되는 트랜잭션이다.
- 작업이 모두 바로 성공/실패해야 하는 [[강한 일관성]]과 느리더라도 결과적으로 모두 성공/실패하는 [[최종 일관성]]으로 나뉜다.
- 이 경우 단일 DB의 로컬 트랜잭션과 다르게, [[ACID]] 속성을 보장하기 어려워진다.
### 왜 ACID를 보장하지 못하는가?
단순히 생각하면 다음처럼 코드를 작성하면 될 것 같다.
```text
method {
	system1.doSomething()
	system1.commit()
	if (system1.noError()) {
		system2.doSomething()
		system2.commit()
		if (!system2.noError()) {
			system2.rollback()
			system1.rollback()
		}
	} else {
		system1.rollback()
	}
}
```
하지만 실제로는 네트워크 지연이나 롤백 자체의 실패 등으로 ACID 속성을 지키기 어렵다.
- system1 성공 -> system2 실패 -> system2 롤백 -> system1 롤백 시도중 실패
- system1 성공 -> system2 성공했으나 성공했다는 응답이 유실 -> system1 실패
- ... 수많은 실패 케이스
## 주요 구현 방식
### Two-Phase Commit : 강한 일관성
- 코디네이터(트랜잭션 관리자) 개념이 존재한다.
- 다음과 같은 단계로 진행된다.
	1. 각 시스템에서 작업을 수행한다. 각 시스템은 작업이 완료되면 코디네이터에게 이를 알린다.
	2. 코디네이터가 모든 시스템이 작업이 완료되었다는 것을 확인하면 `Phase1`을 시작한다.
	3. `Phase1`
		1. 코디네이터는 모든 시스템에게 커밋할 준비가 되었냐고 물어본다.
		2. 각 시스템은 커밋할 준비가 되었다고 응답한다.
		3. 하나라도 커밋할 준비가 되지 않았다면 모두 롤백한다.
		4. 모두 커밋할 준비가 되었다면 `Phase2`를 시작한다.
	4. `Phase2`
		1. 코디네이터가 각 시스템에 커밋을 요청한다.
		2. 요청이 실패하면 코디네이터에 의해 해당 시스템은 재시도된다.
- 즉 `phase1`에서 커밋 약속을 받으면 `phase2`에서는 무조건 커밋을 진행하는게 포인트이다.
- 이 모든 작업은 동기적으로 작동하며, 따라서 강한 일관성을 가진다.
### Saga Pattern : 최종 일관성
- 각 시스템을 각자의 트랜잭션으로 실행시키고, 만약 어떠한 시스템이 실패하면 다른 시스템은 [[보상 트랜잭션]]으로 롤백하는 방식이다.
- 다음과 같은 단계로 진행된다. (이벤트 기반 구현)
	1. 최초 시스템이 이벤트를 발행한다.
	2. 다른 시스템들은 이벤트를 확인하고 자기 작업을 수행한다.
	3. 만약 한 시스템이 문제가 생기면 문제가 생겼다고 이벤트를 발행한다.
	4. 다른 시스템들은 이벤트를 확인하고 보상 트랜잭션을 통해 자기 작업을 롤백한다.
### 기타
- [[아웃박스 패턴]] : DB 업데이트와 메시지 발행을 묶기