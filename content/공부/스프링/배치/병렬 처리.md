- 기본적으로 항상 단일 스레드 / 단일 프로세스 작업만으로도 충분한지 생각해야 한다.
- 병렬 처리는 크게 다음처럼 분류된다.
	- **1 프로세스 N 스레드**
		- 다중 스레드 [[Step]] : 한 step을 여러 스레드가 빠르게 처리한다.
		- 병렬 [[Step]] : 여러 step을 여러 스레드가 동시에 처리한다.
		- 로컬 청킹 [[Step]] : 한 step의 reader는 1스레드가, 나머지는 여러 스레드가 빠르게 처리한다.
	- **N 프로세스**
		- 원격 청킹 [[Step]] : 한 step의 reader는 한 프로세스가, 나머지는 여러 프로세스가 빠르게 처리한다.
		- 파티셔닝 : 한 step을 1스레드가 여러 파티션으로 나누고, 작업을 여러 프로세스가 빠르게 처리한다.
		- 리모트 [[Step]] : 한 step을 여러 프로세스가 빠르게 처리한다.
## Multi-threaded Step
- 여러 chunk를 여러 스레드로 분할하여 처리하는 방식이다.
- Step의 TaskExecutor를 설정하면 된다.
```java
@Bean
public TaskExecutor taskExecutor() {
    return new SimpleAsyncTaskExecutor("spring_batch");
}

@Bean
public Step sampleStep(TaskExecutor taskExecutor, JobRepository jobRepository, PlatformTransactionManager transactionManager) {
	return new StepBuilder("sampleStep", jobRepository)
				.<String, String>chunk(10).transactionManager(transactionManager)
				.reader(itemReader())
				.writer(itemWriter())
				.taskExecutor(taskExecutor)
				.build();
}
```
- 간단한 설정으로 추가할 수 있다.
- **주의**
	- reader, processor, writer가 thread-safe하게 구현되어야 한다.
	- reader가 병렬적으로 작동 -> 항목의 순서가 바뀔 수 있다.
## Parallel Steps
- 여러 step을 병렬로 처리하는 방식이다.
- [[Flow]]를 통해 병렬 처리 구간을 나누고, spit을 사용하면 된다.
![[Pasted image 20251222114523.png]]
```java
@Bean
public Job job(JobRepository jobRepository) {
    return new JobBuilder("job", jobRepository)
        .start(splitFlow())
        .next(step4())
        .build()        //builds FlowJobBuilder instance
        .build();       //builds Job instance
}

@Bean
public Flow splitFlow() {
    return new FlowBuilder<SimpleFlow>("splitFlow")
        .split(taskExecutor())
        .add(flow1(), flow2())
        .build();
}

@Bean
public Flow flow1() {
    return new FlowBuilder<SimpleFlow>("flow1")
        .start(step1())
        .next(step2())
        .build();
}

@Bean
public Flow flow2() {
    return new FlowBuilder<SimpleFlow>("flow2")
        .start(step3())
        .build();
}

@Bean
public TaskExecutor taskExecutor() {
    return new SimpleAsyncTaskExecutor("spring_batch");
}
```
## Local Chunking
- Remote Chunking의 개념을 로컬로 가져왔다.
- 매니저 스레드 1개가 [[ItemReader]]에, 워커 스레드 여러개가 [[ItemReader]]와 [[ItemProcessor]]에 붙는다.
- [[병렬 처리#Multi-threaded Step|Multi-threaded Step]]과 다른점
	- 읽는 것은 단일 스레드 -> 순차적으로 읽힌다.
	- 실제로 시간이 오래걸리는 프로세서와 라이터 만이 병렬 처리 된다.
	- reader는 thread-safe 하지 않아도 된다.
## [Remote Chunking](https://docs.spring.io/spring-batch/reference/scalability.html#remoteChunking)
![[Pasted image 20251222115745.png]]
- I/O 집약적인 [[ItemReader]]와 CPU 집약적인 [[ItemProcessor]]/[[ItemWriter]]를 분리하는 방식이다.
- Master는 ItemReader를 통해 데이터를 읽고 청크 단위로 묶어서 Worker에게 보낸다.
- Worker는 청크 데이터를 수신하여 ItemProcessor와 ItemWriter를 실행하고 처리 결과를 다시 Master에게 보낸다.
- Master와 Worker가 보통 MQ로 통신하게 되기 때문에, 구축 비용이 높다.
## [Partitioning](https://docs.spring.io/spring-batch/reference/scalability.html#partitioning)
- 데이터셋을 나눠서 동일한 step을 여러 worker에게 나눠주는 방식이다.
- worker는 여러 스레드, 또는 여러 원격 서버로 지정할 수도 있어서 수평확장성이 좋다.
- 데이터셋을 나눌 Partitioner를 지정해주고, TaskExecutor가 각 worker에게 실행을 위임하게 된다.
- TaskExecutor를 다른 구현체를 사용하여 worker를 어떻게 지정할지 선택하게 된다.
```java
@Bean
public Step managerStep(JobRepository jobRepository, Step workerStep, Partitioner partitioner) {
	return new StepBuilder("managerStep", jobRepository)
			.partitioner("workerStep", partitioner) // Partitioner 지정
			.step(workerStep) // 작업 대상 Step
			.taskExecutor(new SimpleAsyncTaskExecutor()) // Worker를 실행할 TaskExecutor
			.build();
}
```
## Remote Step execution
- [[Step]] 실행을 외부 Worker에 위임하는 것이다.
- 클라우드/SEDA 기반 확장성을 극대화한다고 한다... 나중에 필요하면 공부하면 될 듯